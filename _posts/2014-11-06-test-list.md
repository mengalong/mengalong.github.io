
<ul id="tree" class="ztree"></ul>
<article class='markdown-body'>

# 问题list
## rsync_data.sh
1. 依赖的 ../conf/sms.conf 中得报警收件人需要修改

## fix_ac_repair.sh
1. 第5、6行有写死的机器名需要注意
	<pre><code>	
		5 CON_HOST="yf-www-maclife.yf01"
		6 BEE_HOST="yf-ps-beehive-con0.yf01"
	</code></pre>

2. 依赖的 ../conf/ac.conf 中也有报警收件人，这个不知道有用吗？有用的话能和上边的统一了吗？
	<pre><code>
	    7 [sms_num]
      	8 sms_num=18511870830
	</code></pre>
3. 第21行，这里的 timeStr 在之前没初始化，这里有问题
	<pre><code>
		 21 ac_init_host_file_bak="/home/work/zhangzhao/auto_fix_machine/bin/init_strategy/bak/ac.host.conf.${timeStr}"
	</code></pre>
4. 第 41~44行，这里也是写死的 ac 机器名，能不写死在代码中吗？
	<pre><code>
	 41 tc_first_host="cp01-ps-wwwac0-t1.cp01"
     42 jx_first_host="m1-ps-wwwac0-j1.m1"
     43 hz_first_host="hz01-ps-wwwac0-h0.hz01"
     44 nj02_first_host="nj02-ps-wwwac0-n1.nj02"
	</code></pre>
5. 第102行，这里又有一个报警函数,里边也是写死的收件人，整个故障维修的流程中到底用哪个报警模块？
	<pre><code>
	101 ###########报警模块
    102 function sendAlarm()
    103 {
    104     local msg=$@
    105     gsmsend "18511870830"@"$msg" &>/dev/null
    106 
    107 }
	</code></pre>
6. 第443行，这里的加锁函数被注释了，这个是否需要？
	<pre><code>
		    443 #####只允许每次只有一个进程在跑
    		444 #get_lock
	</code></pre>
7. 第448行，对初始化环境进行检查，这里还没对机器进行初始化操作，要检查啥？
8. 同上450行，检查故障机器的总量，这里依赖故障机列表，但是机器列表在第一步clean_up的时候已经清空了，没看明白这里是要做啥？
9. 第231行，get_lidc部分，判断机器所属的逻辑机房，只判断了nj02/hz01/cq/cp/yf/m1，对于db、ai、这种呢？或者以后马上有上海机房，这里还需要修改代码？能做成配置形式吗？
10.	第424行，check_bee_con 一样得问题，需要根据机器所属的逻辑机房获取对应beehive的总控机，这里依然如是,新增机房怎么办？
	<pre><code>
	424 function check_bee_con()
    425 {
    426         idc=$1  
    427         if [ "${idc}"x == "tc"x ]
    428         then
    429                 echo "tc-ps-beehive-con0.tc"                                                                                             
    430         elif [ "${idc}"x == "jx"x ]
    431         then                           
    432                 echo "yf-ps-beehive-con0.yf01"                                                                                             
    433         elif [ "${idc}"x == "hz"x ]
    434         then                                                                                                                    
    435                 echo "hz01-ps-beehive-con1.hz01"                                                                                             
    436         elif [ "${idc}"x == "nj02"x ] 
    437         then                      
    438                 echo "nj02-ps-beehive-con1.nj02"
    439         fi
    440 }
	</code></pre>
11. 第372行，获取beehive总控的cluster-id，这里给tc和jx的clusterid都返回的是beijing，实际部署情况是这样吗？印象中jx对应的时beijing，tc对应的时tucheng呢？
	<pre><code>
		   372 function get_idc_bee()                 
    373 {                                          
    374         unset idc               
    375         idc=$1                                                                                                                  
    376         if [ "${idc}"x == "tc"x ]
    377         then                          
    378                 echo "beijing"                                                                                                               
    379         elif [ "${idc}"x == "jx"x ]
    380         then                                       
    381                 echo "beijing"                                                                                                               
    382         elif [ "${idc}"x == "nj02"x ]
    383         then                  
    384                 echo "nanjing"                                                                                                               
    385         elif [ "${idc}"x == "hz"x ]
    386         then                                          
    387                 echo "hangzhou"                                                                                                              
    388         fi                                                  
    389 }               
	</code></pre>
	

12. 第549行，登陆beehive总控获取ac机器上的服务实例id，这里需要加个异常处理吧？这样直接裸写，返回失败怎么做？下边虽然做了判空处理，除了判空是不是还可以做些什么？
	<pre><code>
	549         ins_id=`ssh ${BEE_HOST}  "/home/work/beehive/shell/bin/bhcli machine  list-instance --hostname=${ip}  --cluster=${idc}"`
    550         echo ${ins_id}  
	</code></pre>

13. 第568行，部署单机切日志的crontab，这一步为什么在这里做?不能放到初始化策略中么？另外这里的这个函数看到应该是在lib/gen_ctab.sh 中定义的，但是没找到在哪里source了这个文件？
	<pre><code>
	567                         ####部署日志切割ctab
    568                         gen_log_ctab ${host}
	</code></pre>
	
14. 第570行,这里执行repair动作，执行完之后没有判断返回值 && 也没有等服务部署成功，就直接在572行解开了配送黑名单吗？另外怎么判断是否真正repair成功了？
	<pre><code>
	570                         comm="ssh ${BEE_HOST} '/home/work/beehive/shell/bin/bhcli app-instance execcmd --app_id=${app} --app_instance_id=${ins_id} --cmd_name=repair --cluster=${idc}'"
    571                         echo ${comm} >>${exec_file_name}
    572                         echo "if [ $? -eq 0 ];then ./del_mac_peisong.py ${host};fi"
	</code></pre>
15. 最重要的，故障机器的列表从哪里获取到的？

## fix_us_repair.sh
1. 调用了get_module_host_list获取us机器列表，这个函数中直接执行 lh -l 获取机器列表没有进行返回值判断
2. gen_repair_us_list.sh 中，第83行
3. gen_repair_us_list.sh 第38行，这里grep -f 后边两个文件是相同的，这里是做啥呢？
	<pre><code>     
		38         grep -f  ${version_ui_nginx_host} ${version_ui_nginx_host} > ${version_ui_nginx_us_host}
	</code></pre>
4. 第86行，这里获取服务的列数，依赖机器名的命名规范，这里能不依赖机器名吗？
	<pre><code>
	     86         col=`get_col4host ${hostname}`
	</code></pre>
5. 第160行,这里同步信任关系，没看明白
	<pre><code>
		    160         ./mkssh-kengen ${target_host}
	</code></pre>
6. 第172行，这里同步数据的时候限速是 50M ？
	<pre><code>
		    172          ${SSH} ${target_host} "rsync -avcP work@${source_host}://home/work/start.sh /home/work/    --bwlimit=${RSYNC_RATE_LIMIT}"
	</code></pre>
7. check_md5.sh 第37行，校验目标机器和故障机器之间的文件一致性生成基准的md5文件的时候这里这么多grep -v?怎么管理？如果需要新增文件或者减少文件呢？
	<pre><code>
		     37         ${SSH} ${source_host} "cd /home/work/search/${item}  && nice -19 find . -type f  | grep -v '\.log'|fgrep -v '/.'|fgrep -v './status/status' | xargs md5sum   > /tmp/${item}.md5"
     38         ${SSH} ${target_host} "cd /home/work/search/${item}  && wget ftp://${source_host}://tmp/${item}.md5 -O  ${item}.md5 && md5sum -c ${item}.md5  |grep -v 'OK'|grep -v '.md5'|grep -v '.pid' |g
        rep -v 'hhvm/cache'|grep -v 'log/'|grep -v '^./data' |grep -v '^./shm'| grep -v 'php/var' |grep -v 'shmdict/mmap/' >${item}.ans"
	</code></pre>
	
8. 校验完md5之后判断校验的结果，单机上应该检查那些模块这里又是写死的？为啥不用配置文件中的配置项？
	<pre><code>
	188     ui_nginx_flag=`less ../tmp/${target_host}.ui-nginx.flag`
    189     pr_nginx_flag=`less ../tmp/${target_host}.pr-nginx.flag`
    190     view_ui_flag=`less ../tmp/${target_host}.view-ui.flag`
    191     ui_flag=`less ../tmp/${target_host}.ui.flag`
    192     us_flag=`less ../tmp/${target_host}.us.flag`
	</code></pre>
	
9. 同ac，这里196行，添加crontab是为啥？同时这里也是直接用切割日志的crontab覆盖了单机的crontab配置，这里如果单机有其他的crontab任务怎么处理？
	<pre><code>
	195         ####部署日志切割ctab
    196         gen_log_ctab ${target_host}
	</code></pre>
10. 第205行，删除信任关系的时候使用 sed -i，这个有风险，异常情况下会将信任关系文件改空
	<pre><code>
		    205     ${SSH} ${source_host} "cd .ssh && sed -i '/'"${target_host}"'/d'  authorized_keys"
	</code></pre>
	
</article>



<script type="text/javascript" src="http://i5ting.github.io/git-quick-start/preview/js/jquery-1.10.2.min.js"></script><script type="text/javascript" src="http://i5ting.github.io/git-quick-start/preview/js/jquery.ztree.all-3.5.min.js"></script><script type="text/javascript" src="http://i5ting.github.io/git-quick-start/preview/js/jquery.ztree_toc.js"></script>
<SCRIPT type="text/javascript" > <!-- $(document).ready(function(){ $('#tree').ztree_toc({ is_auto_number:true, documment_selector:'.markdown-body', ztreeStyle: { width:'260px', overflow: 'auto', position: 'fixed', 'z-index': 2147483647, border: '0px none', left: '0px', top: '0px' } }); }); //--> </SCRIPT> 












	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
